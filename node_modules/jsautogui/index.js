"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
// @ts-ignore
const jsautogui_node_1 = __importDefault(require("./build/Release/jsautogui.node"));
const tween = __importStar(require("jstweening"));
const jstweening_1 = require("jstweening");
const native = jsautogui_node_1.default;
const modifiers = [
    "accept", "add", "alt", "altleft", "altright", "apps", "backspace",
    "browserback", "browserfavorites", "browserforward", "browserhome",
    "browserrefresh", "browsersearch", "browserstop", "capslock", "clear",
    "convert", "ctrl", "ctrlleft", "ctrlright", "decimal", "del", "delete",
    "divide", "down", "end", "enter", "esc", "escape", "execute", "f1", "f10",
    "f11", "f12", "f13", "f14", "f15", "f16", "f17", "f18", "f19", "f2", "f20",
    "f21", "f22", "f23", "f24", "f3", "f4", "f5", "f6", "f7", "f8", "f9",
    "final", "hanguel", "hangul", "hanja", "help", "home", "insert", "junja",
    "kana", "kanji", "launchapp1", "launchapp2", "launchmail",
    "launchmediaselect", "left", "modechange", "multiply", "nexttrack",
    "nonconvert", "num0", "num1", "num2", "num3", "num4", "num5", "num6",
    "num7", "num8", "num9", "numlock", "pagedown", "pageup", "pause", "pgdn",
    "pgup", "playpause", "prevtrack", "print", "printscreen", "prntscrn",
    "prtsc", "prtscr", "return", "right", "scrolllock", "select", "separator",
    "shift", "shiftleft", "shiftright", "sleep", "space", "stop", "subtract", "tab",
    "up", "volumedown", "volumemute", "volumeup", "win", "winleft", "winright", "yen",
    "command", "option", "optionleft", "optionright"
];
const mouseButtons = ["left", "right", "middle"];
const INT32_MIN = -2147483648;
const INT32_MAX = 2147483647;
function eType(a, t, n) {
    if (typeof a !== t)
        throw new Error(`Expected ${n} to be a ${t}, instead got: ${typeof a}`);
}
function eInt32(a, n) {
    eSize(a, INT32_MIN, INT32_MAX, n);
    if (a !== Math.floor(a))
        throw new Error(`Expected ${n} to be an int32, instead got a float/double.`);
}
function eSize(a, min, max, n) {
    eType(a, "number", n);
    if (a < min || a > max)
        throw new Error(`Expected ${n} to be between (${min}, ${max}).`);
}
function perm(s) {
    throw new Error(`Couldn't ${s}, is the program lacking some permissions?`);
}
function applyMovement(x1, y1, x2, y2, duration, tween) {
    let interval = null;
    const prom = new Promise((resolve) => {
        let t = 0;
        let last = performance.now();
        interval = setInterval(() => {
            const now = performance.now();
            t += now - last;
            last = now;
            if (t >= duration) {
                native.set_mouse_pos(x2, y2);
                clearInterval(interval);
                resolve();
            }
            else {
                const rt = t / duration;
                const tw = tween(rt);
                API.mouse.setPosition(x1 + (x2 - x1) * tw, y1 + (y2 - y1) * tw);
            }
        });
    });
    return {
        wait: () => prom,
        cancel: () => interval && clearInterval(interval)
    };
}
var KeyPressMode;
(function (KeyPressMode) {
    KeyPressMode[KeyPressMode["ASCII"] = 0] = "ASCII";
    KeyPressMode[KeyPressMode["UNICODE"] = 1] = "UNICODE";
    KeyPressMode[KeyPressMode["SPECIAL"] = 2] = "SPECIAL";
})(KeyPressMode || (KeyPressMode = {}));
function encodeKeyPress(key, mode, down, up) {
    return key | ((mode & 0x3) << 16) | (down ? (1 << 19) : 0) | (up ? (1 << 20) : 0);
}
function encodeKeyPresses(keys, down, up) {
    return keys.map(k => {
        if (typeof k !== "string")
            throw new Error(`Expected key to be a string, instead got: ${typeof k}`);
        if (modifiers.includes(k)) {
            return encodeKeyPress(k, KeyPressMode.SPECIAL, down, up);
        }
        else if (k.length === 1) {
            return encodeKeyPress(k.charCodeAt(0), KeyPressMode.ASCII, down, up);
        }
        else if (k.length <= 4) {
            const c1 = k.charCodeAt(0) || 0;
            const c2 = k.charCodeAt(1) || 0;
            const c3 = k.charCodeAt(2) || 0;
            const c4 = k.charCodeAt(3) || 0;
            const encoded32 = (c1 << 24) | (c2 << 16) | (c3 << 8) | c4;
            return encodeKeyPress(encoded32, KeyPressMode.UNICODE, down, up);
        }
        throw new Error(`Unsupported key format: ${k}`);
    });
}
function keysPress(keys, down, up) {
    native.keys_press(new Uint32Array(encodeKeyPresses(keys, down, up)));
}
function hotkeyPress(keys) {
    native.keys_press(new Uint32Array([
        ...encodeKeyPresses(keys, true, false),
        ...encodeKeyPresses(keys, false, true)
    ]));
}
function xyFix(x, y, min = 0) {
    x = Math.min(INT32_MAX, Math.max(min, Math.round(x)));
    y = Math.min(INT32_MAX, Math.max(min, Math.round(y)));
    return [x, y];
}
let callPause = 0;
let failSafe = false;
let failSafeInterval = null;
const API = {
    __native_do_not_use_this_it_might_crash_natively_if_misused: native,
    get FAIL_SAFE() {
        return failSafe;
    },
    set FAIL_SAFE(v) {
        eType(v, "boolean", "FAIL_SAFE");
        if (v === failSafe)
            return;
        clearInterval(failSafeInterval);
        if (v) {
            failSafeInterval = setInterval(() => {
                const pos = native.get_mouse_pos();
                if (!pos)
                    return;
                if (pos.x < 3 && pos.y < 3)
                    throw new Error("Failed safely. This behavior can be disabled by setting jsautogui.FAIL_SAFE to false.");
            }, 100);
            failSafe = true;
        }
        else {
            failSafe = false;
            failSafeInterval = null;
        }
    },
    get PAUSE() {
        return callPause;
    },
    set PAUSE(v) {
        eInt32(v, "PAUSE");
        eSize(v, 0, INT32_MAX, "PAUSE");
        callPause = v;
        native.set_pause(v);
    },
    mouse: {
        LinearTween: jstweening_1.linear,
        get position() {
            return this.getPosition();
        },
        set position(v) {
            this.setPosition(v.x, v.y);
        },
        get x() {
            return this.position.x;
        },
        set x(v) {
            eInt32(v, "mouse.position.x");
            eSize(v, 0, INT32_MAX, "mouse.position.x");
            if (!native.set_mouse_x(v))
                perm("set the x position of the mouse");
        },
        get y() {
            return this.position.y;
        },
        set y(v) {
            eInt32(v, "mouse.position.y");
            eSize(v, 0, INT32_MAX, "mouse.position.y");
            if (!native.set_mouse_y(v))
                perm("set the y position of the mouse");
        },
        getPosition() {
            const pos = native.get_mouse_pos();
            if (!pos)
                perm("find the position of the mouse");
            const obj = {};
            Object.defineProperties(obj, {
                x: {
                    get: () => pos.x,
                    set: v => this.x = pos.x = v
                },
                y: {
                    get: () => pos.y,
                    set: v => this.y = pos.y = v
                }
            });
            return obj;
        },
        setPosition(x, y) {
            [x, y] = xyFix(x, y);
            if (!native.set_mouse_pos(x, y))
                return perm("set the position of the mouse");
        },
        moveTo(x, y, duration = 0, tween = jstweening_1.linear) {
            [x, y] = xyFix(x, y);
            eInt32(duration, "duration");
            if (duration === 0) {
                this.setPosition(x, y);
                return { wait: () => null, cancel: () => null };
            }
            eType(tween, "function", "mouse.moveTo.tween");
            const start = native.get_mouse_pos();
            return applyMovement(start.x, start.y, x, y, duration, tween);
        },
        moveRel(dx, dy, duration = 0, tween = jstweening_1.linear) {
            [dx, dy] = xyFix(dx, dy, 0);
            eInt32(duration, "duration");
            if (duration === 0) {
                native.set_mouse_pos_rel(dx, dy) || perm("set the position of the mouse");
                return { wait: () => null, cancel: () => null };
            }
            const start = native.get_mouse_pos();
            const x0 = start.x, y0 = start.y;
            return applyMovement(x0, y0, x0 + dx, y0 + dx, duration, tween);
        },
        dragTo(x, y, button = "primary", duration = 0, tween = jstweening_1.linear) {
            [x, y] = xyFix(x, y);
            this.down(button);
            const r = this.moveTo(x, y, duration, tween);
            if (r instanceof Promise)
                return r.then(() => this.up(button));
            this.up(button);
        },
        dragRel(dx, dy, button = "primary", duration = 0, tween = jstweening_1.linear) {
            [dx, dy] = xyFix(dx, dy, 0);
            this.down(button);
            const r = this.moveRel(dx, dy, duration, tween);
            if (r instanceof Promise)
                return r.then(() => this.up(button));
            this.up(button);
        },
        get isSwapped() {
            return native.is_mouse_swapped();
        },
        down(button = "primary") {
            if (button === "primary")
                button = this.isSwapped ? "right" : "left";
            else if (button === "secondary")
                button = this.isSwapped ? "left" : "right";
            else if (mouseButtons.includes(button))
                return native["mouse_" + button + "_down"]() || perm("press a button in mouse");
            throw new Error("Expected the button argument to be 'right', 'left', 'middle', 'primary', 'secondary'. Got: " + button);
        },
        up(button = "primary") {
            if (button === "primary")
                button = this.isSwapped ? "right" : "left";
            if (button === "secondary")
                button = this.isSwapped ? "left" : "right";
            if (mouseButtons.includes(button))
                return native["mouse_" + button + "_up"]() || perm("release a button in mouse");
            throw new Error("Expected the button argument to be 'right', 'left', 'middle', 'primary', 'secondary'. Got: " + button);
        },
        click(button = "primary") {
            if (button === "primary")
                button = this.isSwapped ? "right" : "left";
            if (button === "secondary")
                button = this.isSwapped ? "left" : "right";
            if (mouseButtons.includes(button))
                return native["click_" + button]() || perm("click a button in mouse");
            throw new Error("Expected the button argument to be 'right', 'left', 'middle', 'primary', 'secondary'. Got: " + button);
        },
        scroll(y = 0, x = 0) {
            [x, y] = xyFix(x, y, INT32_MIN);
            if (!native.mouse_scroll(x, y))
                perm("scroll the wheel of mouse");
        },
        hscroll(x = 0, y = 0) {
            [x, y] = xyFix(x, y, INT32_MIN);
            if (!native.mouse_scroll(x, y))
                perm("scroll the wheel of mouse");
        }
    },
    keyboard: {
        press(...keys) {
            keysPress(keys, true, true);
        },
        down(...keys) {
            keysPress(keys, true, false);
        },
        up(...keys) {
            keysPress(keys, false, true);
        },
        write(...texts) {
            for (const text of texts) {
                for (let i = 0; i < text.length; i++)
                    this.press(text[i]);
            }
        },
        hotkey(...keys) {
            hotkeyPress(keys);
        }
    },
    screen: {
        get size() {
            return native.get_screen_size();
        },
        get width() {
            return this.size.width;
        },
        get height() {
            return this.size.height;
        },
        get center() {
            const s = this.size;
            return { x: Math.floor(s.width / 2), y: Math.floor(s.height / 2) };
        },
        includes(x, y) {
            eInt32(x, "x");
            eInt32(y, "y");
            const size = native.get_screen_size();
            return x >= 0 && y >= 0 && x < size.width && y < size.height;
        },
        contains(x, y) {
            return this.includes(x, y);
        }
    }
};
Object.assign(API, tween);
module.exports = API;
